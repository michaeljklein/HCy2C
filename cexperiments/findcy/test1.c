#include <stdio.h>\n\nvoid print_cycle(FILE * outfile, unsigned int * this_current_path){\n\n\n\n    count++;\n}\n\nint main(int argc, const char * argv[]) {\n    unsigned long long count = 0;\n    const unsigned int vo0[3] = {1,2,3};\n    const unsigned int vo1[3] = {0,2,3};\n    const unsigned int vo2[3] = {0,1,3};\n    const unsigned int vo3[3] = {0,1,2};\n    const unsigned int vo4[0] = {};\n    const unsigned int vo5[0] = {};\n    const unsigned int * vos[6] = {vo0,vo1,vo2,vo3,vo4,vo5};\n    const unsigned int vomax[6] = {3,3,3,3,0,0};\n    unsigned int current_path[6];\n    unsigned int adjacency_path[6];\n    register unsigned int path_position = 0;\n    unsigned char fresh[6] = {1,1,1,1,1,1};\n    unsigned char inplay[6] = {1,1,1,1,1,1};\n    register unsigned int start = 0;\n    register unsigned int fresh_found;\n    register unsigned int fresh_found_adjacency;\n\n    register unsigned int possible_fresh;\n    register unsigned int possible_fresh_adjacency;\n    register unsigned int local_max;\n    FILE * outfile = fopen(\"fctest.txt\", \"w\");\n    fwrite(\"[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]\\n\", 1,38,outfile);\n\n    starter_loop:\n    if (start != 2 ) {\n        inplay[start] = 0;\n    fresh[0] = inplay[0]; fresh[1] = inplay[1]; fresh[2] = inplay[2]; fresh[3] = inplay[3]; fresh[4] = inplay[4]; fresh[5] = inplay[5]; \n    current_path[0] = start; current_path[1] = 0; current_path[2] = 0; current_path[3] = 0; current_path[4] = 0; current_path[5] = 0; \n    adjacency_path[0] = 0; adjacency_path[1] = 0; adjacency_path[2] = 0; adjacency_path[3] = 0; adjacency_path[4] = 0; adjacency_path[5] = 0; \n\n        fresh_found = 0;\n        fresh_found_adjacency = 0;\n        path_position = 0;\n        begin_stepper:{\n                local_max = vomax[current_path[path_position]];\n                possible_fresh_adjacency = adjacency_path[path_position];\n                begin_find_fresh:{\n                    possible_fresh = vos[current_path[path_position]][possible_fresh_adjacency];\n                    if (possible_fresh_adjacency != local_max) {\n                        if (possible_fresh == start) {\n                                if (path_position > 1) {\n                                    print_cycle(outfile, current_path);\n                                } else {\n                                        ;\n                                }\n                                possible_fresh_adjacency++;\n                                goto begin_find_fresh;\n                        } else {\n                            if (fresh[possible_fresh] && (possible_fresh_adjacency >= adjacency_path[path_position])) {\n                                fresh_found = possible_fresh;\n                                fresh_found_adjacency = possible_fresh_adjacency;\n                                possible_fresh_adjacency++;\n                                goto begin_check_for_cycle;\n                            }\n                        }\n                        possible_fresh_adjacency++;\n                        goto begin_find_fresh;\n                    } else {\n                        goto end_find_fresh;\n                    }\n                }end_find_fresh: goto step_back;\n            begin_check_for_cycle:{\n                if (possible_fresh_adjacency != local_max) {\n                    possible_fresh = vos[current_path[path_position]][possible_fresh_adjacency];\n                    if (possible_fresh == start) {\n                            if (path_position > 1) {\n                                    print_cycle(outfile, current_path);\n                            } else {\n                                    ;\n                            }\n                            goto end_check_for_cycle;\n                    }\n                    possible_fresh_adjacency++;\n                    goto begin_check_for_cycle;\n                } else {\n                    goto end_check_for_cycle;\n                }\n            }end_check_for_cycle: goto step_forward;\n            step_forward:\n                adjacency_path[path_position] = fresh_found_adjacency;\n                path_position++;\n                current_path[path_position] = fresh_found;\n                fresh[fresh_found] = 0;\n                goto begin_stepper;\n            step_back:\n                if (path_position == 0) {\n                    goto end_stepper;\n                } else {\n                    fresh[current_path[path_position]] = 1;\n                    current_path[path_position] = 0;\n                    adjacency_path[path_position] = 0;\n                    path_position--;\n                    adjacency_path[path_position]++;\n                    goto begin_stepper;\n                }\n        }end_stepper:;\n    \n        start++;\n        goto starter_loop;\n    } else {\n\n            char cstr[21];\n            sprintf(cstr, \"%20llu\n\", count);\n            fwrite(str, 1, 21, outfile);\n            fwrite(\"DONE.\", 1, 5, outfile);\n            fclose(outfile);\n            return 0;\n    }\n    return 0;\n}\n\n
